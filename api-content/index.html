{"posts":[{"title":"2d 图形库开发(一)","content":" 2d 几何图形都是由不同路径组成, 因此要绘制出2d 几何图形.要先从绘制路径开始 ,考虑到路径的宽度的问题, 可以使用三角形来模拟线段组成的路径,同时利用渲染管线的 triangle-list 模式来减少重复顶点的数量提升渲染效率. 在绘制路径之前先规定一下路径绘制过程中的规则 1. 路径由无数条线段组成, 一条线段由两个点组成, 点是路径组成的最小单元 2. 点具有位置属性, 同时由于要模拟线段的宽度,所以我们要模拟出这种宽短,在沿着线段首尾两点组成的向量的法向正方向与法向负方向同时延伸形成线段的宽.因此点还要存储其法向数据 pub struct PathPoint { pub pos: Vector2f, pub normal: Vector2f } 线段 先从最简单的线段入手, 设置两个点组成一条线段,计算组成线段的两个点的法线方向, 如下图 P0P1⃗\\vec{P_0P_1}P0​P1​​ 为向量方向 , 则向量法向为 垂直P0P1⃗\\vec{P_0P_1}P0​P1​​的P0A⃗\\vec{P_0A}P0​A​因此线段的宽度可以由 P0P1⃗\\vec{P_0P_1}P0​P1​​ 向其法线两侧延伸 // ... pub fn stroke_line(points:&amp;[PathPoint] , stroke:Stroke , out:&amp;mut Mesh){ let w = stroke.width * 0.5; let idx = out.vertices.len() as u16; out.color_triangle(points[0].pos + points[0].normal * w, Color::WHITE); out.color_triangle(points[0].pos - points[0].normal * w, Color::WHITE); out.color_triangle(points[1].pos + points[1].normal * w, Color::WHITE); out.color_triangle(points[1].pos - points[1].normal * w, Color::WHITE); out.add_triangle(idx + 0, idx + 2, idx + 3); out.add_triangle(idx + 0, idx + 1, idx + 3); } // ... 其法向的计算也很简单,计算出线段的方向向量之后,对此此向量进行单位化,再将其旋转 90度即可求得其法向方向. pub fn add_line_segment(&amp;mut self , pos:[Vector2f;2]) { // 获取到线段法向量 let normal = (pos[1] - pos[0]).normalize().rot_90(); self.add_point(pos[0], normal); self.add_point(pos[1], normal); } 采用此方法绘制直线的缺点就是会导致顶点数增加, 对于一条线段来说其顶点由 2 个拓展为 4 个. 绘制结果 折角绘制 对于两条线段连接处的绘制如果不做处理的话就会出现 这种情况,为了使得两条线段连接处显得更加的平滑,需要对折角处进行处理 首先找到两条线段的单位法向向量 jd⃗\\vec{jd}jd​ 、jf⃗\\vec{jf}jf​ ,通过平行四边形法则计算得出两线段折角平分线方向 jm⃗\\vec{jm}jm​ , 此为 2 个单位宽度的法向量长度 , 因此要获得折角平分线在 单位宽度的长度时还要将其除以 2.0 , 从 j 点出发, 沿着此方向及其负方向各 延伸出一个顶点,作为折角点, 最终连接延伸出来的 6 个顶点构建出 4 个新的三角形来实现对线段连接折角的处理 代码实现 pub fn add_line_opened(&amp;mut self , positions:Vec&lt;Vector2f&gt;) { let n = positions.len(); self.reserve(n); // 由于目前不考虑路径闭合的情形 因此 第一个点与最后一个点要单独算 let mut n0 = (positions[1] - positions[0]).normalize().rot_90(); self.add_point(positions[0], n0); for i in 1..n - 1 { let mut n1 = (positions[i + 1] - positions[i]).normalize().rot_90(); if n0 == Vector2f::ZERO { n0 = n1; }else if n1 == Vector2f::ZERO { n1 = n0; } let normal = ((n0 + n1) / 2.0).normalize(); self.add_point(positions[i], normal); n0 = n1; } // 计算最后一个点 self.add_point(positions[n - 1], (positions[n - 1] - positions[ n - 2]).normalize().rot_90()); } // 生成顶点数据 pub fn stroke_path(points:&amp;[PathPoint] , stroke:Stroke , out:&amp;mut Mesh ) { let w = stroke.width * 0.5; let idx = out.vertices.len() as u16; let n = points.len(); out.reserve_vertex( n * 2); out.reserve_index(n * 2); let step = 2_u16; for i in 0..n { let is_connect_prev_point = if i &gt; 0 { true } else { false }; out.color_triangle(points[i].pos + points[i].normal * w, Color::WHITE); out.color_triangle(points[i].pos - points[i].normal * w, Color::WHITE); if is_connect_prev_point { let i = (i - 1) as u16; // // [ 0 , 1 , 3 ] // [ 0 , 2 , 3 ] // [ 2, 3, 5 ] // [ 2 , 4 , 5 ] out.add_triangle(idx + i * step + 0, idx + i * step + 1, idx + i * step + 3); out.add_triangle(idx + i * step + 0, idx + i * step + 2, idx + i * step + 3); } } } 最终效果: 可以看到已经达到来预期的效果,但是还是可以发现线条上出现了锯齿,下期来实现一下线条的反走样效果. 参考资料 使用 OpenGL 实现线型动画的教程来啦！ 在 WebGL 中绘制直线 egui ","link":"https://gty215615.github.io/post/2d-tu-xing-ku-kai-fa-yi/"},{"title":" 2d 图形库开发","content":" 由于最近学习 WebGPU 没有目标, 加上最近对 2d 图形库的实现比较感兴趣, 所以想实现一个玩具2d 图形系统来检验自己的学习成果. 因此就有了这个项目, 开了个新坑, 希望能坚持下去 🐶 实现思路 目前整体设计思路就是: 实现 2d 图元 线(line) 、矩形(rectangle) 、圆(circle) 、曲线(curve), 并将 2d 图形拆分成不同大小的三角形图元, 将这些图元传递到 WebGPU 的渲染管线中去绘制. 项目搭建 整体思路确定下来之后 就是进行项目开发 , 准备用 rust 开发这个 2d 图形库, 窗口使用 winit 库 , 渲染后端使用 WebGPU 的 rust 实现 wgpu , 用 cargo 来创建一个新的 rust 项目 , 新建几个子项目 ,整理项目结构如下 对项目进行的分层 , 包括 核心层(core)、工具层(function) , 1. core 中包括了 数学库(math) 、 颜色(color) 2. function 中包括了渲染后端(render)、窗口(window)、2d 绘制模块(paint) 项目构建完毕,下期正式开始开发. ","link":"https://gty215615.github.io/post/cong-ling-shi-xian-yi-ge-gui-xi-tong/"}]}