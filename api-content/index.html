{"posts":[{"title":"2d å›¾å½¢åº“å¼€å‘(ä¸€)","content":" 2d å‡ ä½•å›¾å½¢éƒ½æ˜¯ç”±ä¸åŒè·¯å¾„ç»„æˆ, å› æ­¤è¦ç»˜åˆ¶å‡º2d å‡ ä½•å›¾å½¢.è¦å…ˆä»ç»˜åˆ¶è·¯å¾„å¼€å§‹ ,è€ƒè™‘åˆ°è·¯å¾„çš„å®½åº¦çš„é—®é¢˜, å¯ä»¥ä½¿ç”¨ä¸‰è§’å½¢æ¥æ¨¡æ‹Ÿçº¿æ®µç»„æˆçš„è·¯å¾„,åŒæ—¶åˆ©ç”¨æ¸²æŸ“ç®¡çº¿çš„ triangle-list æ¨¡å¼æ¥å‡å°‘é‡å¤é¡¶ç‚¹çš„æ•°é‡æå‡æ¸²æŸ“æ•ˆç‡. åœ¨ç»˜åˆ¶è·¯å¾„ä¹‹å‰å…ˆè§„å®šä¸€ä¸‹è·¯å¾„ç»˜åˆ¶è¿‡ç¨‹ä¸­çš„è§„åˆ™ 1. è·¯å¾„ç”±æ— æ•°æ¡çº¿æ®µç»„æˆ, ä¸€æ¡çº¿æ®µç”±ä¸¤ä¸ªç‚¹ç»„æˆ, ç‚¹æ˜¯è·¯å¾„ç»„æˆçš„æœ€å°å•å…ƒ 2. ç‚¹å…·æœ‰ä½ç½®å±æ€§, åŒæ—¶ç”±äºè¦æ¨¡æ‹Ÿçº¿æ®µçš„å®½åº¦,æ‰€ä»¥æˆ‘ä»¬è¦æ¨¡æ‹Ÿå‡ºè¿™ç§å®½çŸ­,åœ¨æ²¿ç€çº¿æ®µé¦–å°¾ä¸¤ç‚¹ç»„æˆçš„å‘é‡çš„æ³•å‘æ­£æ–¹å‘ä¸æ³•å‘è´Ÿæ–¹å‘åŒæ—¶å»¶ä¼¸å½¢æˆçº¿æ®µçš„å®½.å› æ­¤ç‚¹è¿˜è¦å­˜å‚¨å…¶æ³•å‘æ•°æ® pub struct PathPoint { pub pos: Vector2f, pub normal: Vector2f } çº¿æ®µ å…ˆä»æœ€ç®€å•çš„çº¿æ®µå…¥æ‰‹, è®¾ç½®ä¸¤ä¸ªç‚¹ç»„æˆä¸€æ¡çº¿æ®µ,è®¡ç®—ç»„æˆçº¿æ®µçš„ä¸¤ä¸ªç‚¹çš„æ³•çº¿æ–¹å‘, å¦‚ä¸‹å›¾ P0P1âƒ—\\vec{P_0P_1}P0â€‹P1â€‹â€‹ ä¸ºå‘é‡æ–¹å‘ , åˆ™å‘é‡æ³•å‘ä¸º å‚ç›´P0P1âƒ—\\vec{P_0P_1}P0â€‹P1â€‹â€‹çš„P0Aâƒ—\\vec{P_0A}P0â€‹Aâ€‹å› æ­¤çº¿æ®µçš„å®½åº¦å¯ä»¥ç”± P0P1âƒ—\\vec{P_0P_1}P0â€‹P1â€‹â€‹ å‘å…¶æ³•çº¿ä¸¤ä¾§å»¶ä¼¸ // ... pub fn stroke_line(points:&amp;[PathPoint] , stroke:Stroke , out:&amp;mut Mesh){ let w = stroke.width * 0.5; let idx = out.vertices.len() as u16; out.color_triangle(points[0].pos + points[0].normal * w, Color::WHITE); out.color_triangle(points[0].pos - points[0].normal * w, Color::WHITE); out.color_triangle(points[1].pos + points[1].normal * w, Color::WHITE); out.color_triangle(points[1].pos - points[1].normal * w, Color::WHITE); out.add_triangle(idx + 0, idx + 2, idx + 3); out.add_triangle(idx + 0, idx + 1, idx + 3); } // ... å…¶æ³•å‘çš„è®¡ç®—ä¹Ÿå¾ˆç®€å•,è®¡ç®—å‡ºçº¿æ®µçš„æ–¹å‘å‘é‡ä¹‹å,å¯¹æ­¤æ­¤å‘é‡è¿›è¡Œå•ä½åŒ–,å†å°†å…¶æ—‹è½¬ 90åº¦å³å¯æ±‚å¾—å…¶æ³•å‘æ–¹å‘. pub fn add_line_segment(&amp;mut self , pos:[Vector2f;2]) { // è·å–åˆ°çº¿æ®µæ³•å‘é‡ let normal = (pos[1] - pos[0]).normalize().rot_90(); self.add_point(pos[0], normal); self.add_point(pos[1], normal); } é‡‡ç”¨æ­¤æ–¹æ³•ç»˜åˆ¶ç›´çº¿çš„ç¼ºç‚¹å°±æ˜¯ä¼šå¯¼è‡´é¡¶ç‚¹æ•°å¢åŠ , å¯¹äºä¸€æ¡çº¿æ®µæ¥è¯´å…¶é¡¶ç‚¹ç”± 2 ä¸ªæ‹“å±•ä¸º 4 ä¸ª. ç»˜åˆ¶ç»“æœ æŠ˜è§’ç»˜åˆ¶ å¯¹äºä¸¤æ¡çº¿æ®µè¿æ¥å¤„çš„ç»˜åˆ¶å¦‚æœä¸åšå¤„ç†çš„è¯å°±ä¼šå‡ºç° è¿™ç§æƒ…å†µ,ä¸ºäº†ä½¿å¾—ä¸¤æ¡çº¿æ®µè¿æ¥å¤„æ˜¾å¾—æ›´åŠ çš„å¹³æ»‘,éœ€è¦å¯¹æŠ˜è§’å¤„è¿›è¡Œå¤„ç† é¦–å…ˆæ‰¾åˆ°ä¸¤æ¡çº¿æ®µçš„å•ä½æ³•å‘å‘é‡ jdâƒ—\\vec{jd}jdâ€‹ ã€jfâƒ—\\vec{jf}jfâ€‹ ,é€šè¿‡å¹³è¡Œå››è¾¹å½¢æ³•åˆ™è®¡ç®—å¾—å‡ºä¸¤çº¿æ®µæŠ˜è§’å¹³åˆ†çº¿æ–¹å‘ jmâƒ—\\vec{jm}jmâ€‹ , æ­¤ä¸º 2 ä¸ªå•ä½å®½åº¦çš„æ³•å‘é‡é•¿åº¦ , å› æ­¤è¦è·å¾—æŠ˜è§’å¹³åˆ†çº¿åœ¨ å•ä½å®½åº¦çš„é•¿åº¦æ—¶è¿˜è¦å°†å…¶é™¤ä»¥ 2.0 , ä» j ç‚¹å‡ºå‘, æ²¿ç€æ­¤æ–¹å‘åŠå…¶è´Ÿæ–¹å‘å„ å»¶ä¼¸å‡ºä¸€ä¸ªé¡¶ç‚¹,ä½œä¸ºæŠ˜è§’ç‚¹, æœ€ç»ˆè¿æ¥å»¶ä¼¸å‡ºæ¥çš„ 6 ä¸ªé¡¶ç‚¹æ„å»ºå‡º 4 ä¸ªæ–°çš„ä¸‰è§’å½¢æ¥å®ç°å¯¹çº¿æ®µè¿æ¥æŠ˜è§’çš„å¤„ç† ä»£ç å®ç° pub fn add_line_opened(&amp;mut self , positions:Vec&lt;Vector2f&gt;) { let n = positions.len(); self.reserve(n); // ç”±äºç›®å‰ä¸è€ƒè™‘è·¯å¾„é—­åˆçš„æƒ…å½¢ å› æ­¤ ç¬¬ä¸€ä¸ªç‚¹ä¸æœ€åä¸€ä¸ªç‚¹è¦å•ç‹¬ç®— let mut n0 = (positions[1] - positions[0]).normalize().rot_90(); self.add_point(positions[0], n0); for i in 1..n - 1 { let mut n1 = (positions[i + 1] - positions[i]).normalize().rot_90(); if n0 == Vector2f::ZERO { n0 = n1; }else if n1 == Vector2f::ZERO { n1 = n0; } let normal = ((n0 + n1) / 2.0).normalize(); self.add_point(positions[i], normal); n0 = n1; } // è®¡ç®—æœ€åä¸€ä¸ªç‚¹ self.add_point(positions[n - 1], (positions[n - 1] - positions[ n - 2]).normalize().rot_90()); } // ç”Ÿæˆé¡¶ç‚¹æ•°æ® pub fn stroke_path(points:&amp;[PathPoint] , stroke:Stroke , out:&amp;mut Mesh ) { let w = stroke.width * 0.5; let idx = out.vertices.len() as u16; let n = points.len(); out.reserve_vertex( n * 2); out.reserve_index(n * 2); let step = 2_u16; for i in 0..n { let is_connect_prev_point = if i &gt; 0 { true } else { false }; out.color_triangle(points[i].pos + points[i].normal * w, Color::WHITE); out.color_triangle(points[i].pos - points[i].normal * w, Color::WHITE); if is_connect_prev_point { let i = (i - 1) as u16; // // [ 0 , 1 , 3 ] // [ 0 , 2 , 3 ] // [ 2, 3, 5 ] // [ 2 , 4 , 5 ] out.add_triangle(idx + i * step + 0, idx + i * step + 1, idx + i * step + 3); out.add_triangle(idx + i * step + 0, idx + i * step + 2, idx + i * step + 3); } } } æœ€ç»ˆæ•ˆæœ: å¯ä»¥çœ‹åˆ°å·²ç»è¾¾åˆ°æ¥é¢„æœŸçš„æ•ˆæœ,ä½†æ˜¯è¿˜æ˜¯å¯ä»¥å‘ç°çº¿æ¡ä¸Šå‡ºç°äº†é”¯é½¿,ä¸‹æœŸæ¥å®ç°ä¸€ä¸‹çº¿æ¡çš„åèµ°æ ·æ•ˆæœ. å‚è€ƒèµ„æ–™ ä½¿ç”¨ OpenGL å®ç°çº¿å‹åŠ¨ç”»çš„æ•™ç¨‹æ¥å•¦ï¼ åœ¨ WebGL ä¸­ç»˜åˆ¶ç›´çº¿ egui ","link":"https://gty215615.github.io/post/2d-tu-xing-ku-kai-fa-yi/"},{"title":" 2d å›¾å½¢åº“å¼€å‘","content":" ç”±äºæœ€è¿‘å­¦ä¹  WebGPU æ²¡æœ‰ç›®æ ‡, åŠ ä¸Šæœ€è¿‘å¯¹ 2d å›¾å½¢åº“çš„å®ç°æ¯”è¾ƒæ„Ÿå…´è¶£, æ‰€ä»¥æƒ³å®ç°ä¸€ä¸ªç©å…·2d å›¾å½¢ç³»ç»Ÿæ¥æ£€éªŒè‡ªå·±çš„å­¦ä¹ æˆæœ. å› æ­¤å°±æœ‰äº†è¿™ä¸ªé¡¹ç›®, å¼€äº†ä¸ªæ–°å‘, å¸Œæœ›èƒ½åšæŒä¸‹å» ğŸ¶ å®ç°æ€è·¯ ç›®å‰æ•´ä½“è®¾è®¡æ€è·¯å°±æ˜¯: å®ç° 2d å›¾å…ƒ çº¿(line) ã€çŸ©å½¢(rectangle) ã€åœ†(circle) ã€æ›²çº¿(curve), å¹¶å°† 2d å›¾å½¢æ‹†åˆ†æˆä¸åŒå¤§å°çš„ä¸‰è§’å½¢å›¾å…ƒ, å°†è¿™äº›å›¾å…ƒä¼ é€’åˆ° WebGPU çš„æ¸²æŸ“ç®¡çº¿ä¸­å»ç»˜åˆ¶. é¡¹ç›®æ­å»º æ•´ä½“æ€è·¯ç¡®å®šä¸‹æ¥ä¹‹å å°±æ˜¯è¿›è¡Œé¡¹ç›®å¼€å‘ , å‡†å¤‡ç”¨ rust å¼€å‘è¿™ä¸ª 2d å›¾å½¢åº“, çª—å£ä½¿ç”¨ winit åº“ , æ¸²æŸ“åç«¯ä½¿ç”¨ WebGPU çš„ rust å®ç° wgpu , ç”¨ cargo æ¥åˆ›å»ºä¸€ä¸ªæ–°çš„ rust é¡¹ç›® , æ–°å»ºå‡ ä¸ªå­é¡¹ç›® ,æ•´ç†é¡¹ç›®ç»“æ„å¦‚ä¸‹ å¯¹é¡¹ç›®è¿›è¡Œçš„åˆ†å±‚ , åŒ…æ‹¬ æ ¸å¿ƒå±‚(core)ã€å·¥å…·å±‚(function) , 1. core ä¸­åŒ…æ‹¬äº† æ•°å­¦åº“(math) ã€ é¢œè‰²(color) 2. function ä¸­åŒ…æ‹¬äº†æ¸²æŸ“åç«¯(render)ã€çª—å£(window)ã€2d ç»˜åˆ¶æ¨¡å—(paint) é¡¹ç›®æ„å»ºå®Œæ¯•,ä¸‹æœŸæ­£å¼å¼€å§‹å¼€å‘. ","link":"https://gty215615.github.io/post/cong-ling-shi-xian-yi-ge-gui-xi-tong/"}]}